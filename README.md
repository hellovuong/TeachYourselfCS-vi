Tự học Khoa học Máy Tính
===============================

Lưu ý: trang hướng dẫn này đãc có những thay đổi lớn vào tháng 5/2020. Để xem phiên bản trước, [click vào đây](https://teachyourselfcs.com/2016/).

Nếu bạn là một kỹ sư tự học hoặc tốt nghiệp từ bootcamp, bạn nợ chính bản thân mình việc học khoa học máy tính (KHMT). Rất may, bạn có thể tham gia một chương trình giáo dục KHMT đẳng cấp thế giới mà không cần đầu tư nhiều năm và hay một lượng tiền tương đối để có một tấm bằng 💸.

Có tương đối nhiều nguồn tài liệu ngoài kia, nhưng một số tài liệu thì tốt hơn số khác. Bạn không cần một danh sách kiểu "200 khoá học trực tuyến miễn phí". Bạn cần các câu trả lời nhưng câu hỏi sau:

- Bạn nên học **những chủ đề** nào, và tại sao?
- **Cuốn sách hay video bài giảng** hay nhất cho từng chủ đề là gì?

Trang hướng dẫn này là nỗ lực của chúng tôi để trả lời dứt điểm những câu hỏi này.

Tóm tắt
------

Học tất cả chín chủ đề dưới đây, tốt nhất là theo thứ tự như đã trình bày, sử dụng loạt bài giảng video hoặc sách giáo trình được gợi ý, nhưng lý tưởng nhất là học cả hai. Hãy đặt mục tiêu cho 100-200 giờ nghiên cứu cho mỗi chủ đề, sau đó xem lại các chủ đề yêu thích trong suốt sự nghiệp của bạn 🚀.

|Chủ đề|Tại sao học?|Sách|Video|
|:------|:---------|:---|:-----|
| **[Lập trình](https://teachyourselfcs.com/#programming)**| Đừng là người “chưa bao giờ hiểu rõ” về một thứ như đệ quy.|*Cấu trúc và diễn giải các chương trình máy tính*|Brian Harvey's Berkeley CS 61A|
|**[Kiến trúc máy tính](https://teachyourselfcs.com/#architecture)**|Nếu bạn không có nền tẳng vững chắc về cách máy tính thực sự hoạt động, tất cả các bản abstraction cao hơn của bạn sẽ trở nên không mạch lạc.|*Hệ thống máy tính: Góc nhìn của một lập trình viên*|Berkeley CS 61C|
|**[Thuật toán và cấu trúc dữ liệu](https://teachyourselfcs.com/#algorithm)**| Nếu bạn không biết cách sử dụng cấu trúc dữ liệu phổ biến như ngăn xếp, hàng đợi, cây, và đồ thị, bạn sẽ không có thể giải quyết các vấn đề khó.|*Hướng dẫn Thiết kế Thuật toán*|Bài giảng của Steven Skiena|
|**[Toán cho KHMT](https://teachyourselfcs.com/#math)**| KHMT về cơ bản là một nhánh của toán học ứng dụng, vì vậy học toán sẽ mang lại cho bạn lợi thế cạnh tranh.|*Toán học cho Khoa học Máy tính*|MIT 6.042J của Tom Leighton|
|**[Hệ điều hành](https://teachyourselfcs.com/#operating-systems)**| Hầu hết các đoạn mã bạn viết được chạy bởi một hệ điều hành, vì vậy bạn nên biết chúng tương tác như thế nào.|*Hệ điều hành: Ba mảnh dễ dàng*|Berkeley CS 162|
|**[Mạng máy tính](https://teachyourselfcs.com/#networking)**|Internet là một vấn đề lớn: bạn cần hiểu cách nó hoạt động để khai thác hết tiềm năng của nó.|*Mạng máy tính: một cách tiếp cận từ tầng trên xuống dưới*|Stanford CS 144|
|**[Cơ sở dữ liệu](https://teachyourselfcs.com/#databases)**|Dữ liệu là trọng tâm của hầu hết các chương trình quan trọng, nhưng ít người hiểu cách hệ thống cơ sở dữ liệu thực sự hoạt động.|*Đọc trong Hệ thống Cơ sở Dữ liệu*|Joe Hellerstein's Berkeley CS 186|
|**[Ngôn ngữ và Trình biên dịch](https://teachyourselfcs.com/#languages)**|Nếu bạn hiểu cách ngôn ngữ và trình biên dịch thực sự hoạt động, bạn sẽ viết mã tốt hơn và học ngôn ngữ mới dễ dàng hơn.|*Tạo thông dịch viên*|Khóa học của Alex Aiken trên edX|
|**[Hệ thống phân tán](https://teachyourselfcs.com/#distributed-systems)**|Ngày nay, *hầu hết* hệ thống là phân tán.|*Thiết kế các ứng dụng tập trung về dữ liệu* của Martin Kleppmann|MIT 6.824|

Vẫn còn quá nhiều?
---------------

Nếu ý tưởng tự học 9 chủ đề trong nhiều năm làm bạn cảm thấy quá sức, chúng tôi khuyên bạn chỉ nên tập trung vào hai cuốn sách: *Hệ thống máy tính: Quan điểm của một lập trình viên* và *Thiết kế các ứng dụng tập trung về dữ liệu*. Theo kinh nghiệm của chúng tôi, hai cuốn sách này mang lại hiệu quả cực kỳ cao trên tổng thời gian đầu tư học, đặc biệt cho các kỹ sư tự học và tốt nghiệp từ bootcamp làm việc trên các ứng dụng trực tuyến. Chúng cũng có thể được coi là chất xúc tác giúp bạn có động lực học các chủ đề còn lại.

Tại sao phải học khoa học máy tính?
---------------------------

Có 2 loại kỹ sư phần mềm: 

- những người hiểu rõ về khoa học máy tính để làm những công việc đầy thử thách và sáng tạo. 
- những người chỉ làm việc đều đều vì họ đã quen thuộc với một số công cụ.

Cả hai đều tự gọi mình là kỹ sư phần mềm và cả hai đều có xu hướng kiếm được mức lương tương tự khi mới vào nghề. Nhưng các kỹ sư loại 1 sẽ tiến tới công việc hoàn thiện hơn và được trả lương cao, xứng đáng hơn theo thời gian, cho dù đó là các dự án thương mại hay các dự án nguồn mở, người quản lý về kỹ thuật hay bản thân là cá nhân xuất sắc.

Các kỹ sư loại 1 tìm cách học chuyên sâu về KHMT, cho dù thông qua các kiểu học truyền thống hay bằng cách học hỏi không ngừng nghỉ trong suốt sự nghiệp của họ. Các kỹ sư loại 2 thường chỉ ở trên bề mặt, học các công cụ và công nghệ cụ thể hơn là nền tảng cơ bản tạo ra chúng, chỉ học các kỹ năng mới khi các công nghệ mới diễn ra và xuất hiện.

Hiện tại, số lượng người vào ngành IT đang tăng lên nhanh chóng, trong khi số lượng người tốt nghiệp KHMT thì  tương đối ổn định. Tình trạng dư cung của cá kỹ sư loại 2 này đang bắt đầu làm giảm cơ hội việc làm của chính họ, và đẩy họ ra khỏi ngành IT. Cho dù bạn đang phấn đấu để trở thành kỹ sư loại 1 hay chỉ đơn giản là tìm kiếm công việc an toàn hơn, học KHMT là con đường đúng đắn duy nhất.

[![@todo](./Teach%20Yourself%20Computer%20Science_files/bilotta-tweet.png)](https://twitter.com/jenna/status/838161631662092289)

Hướng dẫn chi tiết cho các chủ đề
--------------

### Lập trình

Hầu hết các chương trình đại học cho ngành KHMT đều bắt đầu với phần “giới thiệu” về lập trình máy tính. Các khóa học tốt nhất cho chủ đề này không chỉ giúp cho người mới học, mà còn rất tốt chho những người đã bỏ lỡ các khái niệm và mô hình lập trình khi họ mới học viết mã.

Gợi ý chung nhất của chúng tôi cho nội dung này là cuốn sách kinh điển *Cấu trúc và diễn giải các chương trình máy tính* (SICP - viết tắt tên tiếng Anh). Nó được cung cấp trực tuyến miễn phí dưới dạng [sách điện tử](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html), và dưới dạng một tập hợp [các bài giảng video của MIT](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/). Mặc dù những bài giảng đó rất hay, nhưng đề xuất video của chúng tôi là [bài giảng SICP của Brian Harvey](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter) (cho khóa học 61A tại Berkeley). Các bài giảng này được trau chuốt hơn và hướng đến đối tượng là sinh viên mới tốt hơn so với các bài giảng của MIT.

Chúng tôi khuyên bạn nên học qua ít nhất ba chương đầu tiên của SICP và làm các bài tập. Để thực hành thêm, hãy thử giải quyết một loạt các bài tập về lập trình nhỏ trên [exercism.io](http://exercism.io/).

Kể từ khi hướng dẫn này được đăng lần đầu tiên vào năm 2016, một trong những câu hỏi thường gặp nhất là liệu bây giờ chúng tôi có nên đề xuất các video mới hơn của khoá học 61A do John DeNero dạy, và/hoặc cuốn sách tương tự *[Soạn thảo chương trình](https://composingprograms.com/)*, vẫn là cuốn sách SICP nhưng sử dụng Python. Chúng tôi nghĩ rằng các tài liệu của DeNero rất tuyệt và một số sinh viên có thể thích chúng hơn, nhưng chúng tôi vẫn đề xuất cuố sách gốc của SICP, Scheme, và các bài giảng của Brian Harvey như là nguồn tài nguyên đầu tiên nên thử.

Tại sao? Bởi vì SICP đặc biệt, ít nhất là nhiều khả năng, trong việc thay đổi suy nghĩ cơ bản của bạn về máy tính và lập trình. Không phải ai cũng sẽ cảm nhận được điều này. Một số sẽ ghét cuốn sách, những người khác sẽ không vượt qua được vài trang đầu tiên. Nhưng giá trị tiềm năng mà nó mang lại rất đáng để thử.

Nếu bạn không cảm thấy thích SICP, hãy thử *[Soạn thảo chương trình](https://composingprograms.com/)*. Nếu vẫn không phù hợp, hãy thử *[Cách thiết kế các chương trình](http://www.htdp.org/)*. Nếu không có tài liệu nào trong số này làm bạn cảm thấy bạn có thể dành công sức cho nó, có lẽ đó là một dấu hiệu cho thấy bạn nên tập trung vào các chủ đề khác trong một thời gian và xem lại chủ đề lập trình này trong một hoặc hai năm nữa.

Cuối cùng, một điểm cần làm rõ: hướng dẫn này KHÔNG được thiết kế cho những người hoàn toàn mới học lập trình. Chúng tôi giả định rằng bạn là một lập trình viên có năng lực mà không có nền tảng về KHMT, đang tìm cách lấp đầy một số lỗ hổng kiến ​​thức. Thực tế là chúng tôi đặt ra một chủ đề về "lập trình" chỉ đơn giản là một lời nhắc nhở rằng bạn có thể cần tìm hiểu nhiều hơn nữa. Đối với những người chưa bao giờ viết mã trước đây, nhưng nếu muốn, bạn có thể thích một hướng dẫn như [cái này](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started).


[![@todo Structure and Interpretation of Computer Programs](./Teach%20Yourself%20Computer%20Science_files/sicp.jpg)](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)

### Kiến trúc máy tính

Kiến trúc Máy tính — đôi khi được gọi là “hệ thống máy tính” hoặc “tổ chức của máy tính” — là một góc nhìn quan trọng đầu tiên về phần tính toán bên dưới bề mặt của phần mềm. Theo kinh nghiệm của chúng tôi, đó là lĩnh vực bị bỏ qua nhất trong các kỹ sư phần mềm tự học.

Cuốn sách yêu thích để giới thiệu của chúng tôi là *[Hệ thống máy tính: Góc nhìn của một lập trình viên (CS:APP - tên viết tắt tiếng Anh)](http://csapp.cs.cmu.edu/3e/home.html)* và khóa học điển hình sử dụng cuốn sách này [sẽ bao gồm](http://csapp.cs.cmu.edu/3e/courses.html) hầu hết các chương 1-6.

Chúng tôi thích cuốn sách CS:APP vì cách tiếp cận thực tế, hướng đến lập trình viên. Mặc dù vẫn có nhiều thứ về kiến ​​trúc máy tính trong hơn những gì được đề cập trong cuốn sách, nhưng nó là một điểm khởi đầu tuyệt vời cho những ai muốn hiểu về hệ thống máy tính nhằm để viết ra các *phần mềm* nhanh hơn, hiệu quả hơn, và đáng tin cậy hơn.

Đối với những người muốn có phần giới thiệu nhẹ nhàng hơn về chủ đề này và sự cân bằng giữa phần cứng và phần mềm, chúng tôi đề xuất *Các yếu tố của hệ thống máy tính*, còn được gọi là “Nand2Tetris”. Đây là một cuốn sách đầy tham vọng nhằm cung cấp cho bạn sự hiểu biết đầy đủ về cách mọi thứ trong máy tính hoạt động. Mỗi chương liên quan đến việc xây dựng một phần nhỏ của hệ thống tổng thể, từ việc viết các cổng logic cơ bản trong HDL, thông qua CPU và assembler, cho đến một ứng dụng có kích thước bằng một trò chơi Tetris.

Chúng tôi khuyên đọc sáu chương đầu tiên của cuốn sách và hoàn thành các dự án liên quan. Điều này sẽ giúp bạn hiểu được mối quan hệ giữa kiến ​​trúc của máy tính và phần mềm chạy trên đó.

Nửa đầu của cuốn sách (và tất cả các dự án của cuốn sách), được cung cấp miễn phí từ [trang web Nand2Tetris](http://www.nand2tetris.org/). Nó cũng có sẵn dưới dạng [một khóa học Coursera với video đi kèm](https://www.coursera.org/learn/build-a-computer).

Khi tìm kiếm sự đơn giản và gắn kết, Nand2Tetris đánh đổi với độ sâu của kiến thức. Đặc biệt, hai khái niệm rất quan trọng trong kiến ​​trúc máy tính hiện đại là pipelining và phân cấp bộ nhớ, nhưng cả hai đều hầu như không có trong sách.

Khi bạn cảm thấy thoải mái với nội dung của Nand2Tetris, chúng tôi khuyên bạn nên quay lại CS: APP hoặc xem xét cuốn sách kinh điển và xuất sắc *[Tổ chức máy tính và thiết kế](https://smile.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269)* của Patterson và Hennessy. Không phải mọi phần trong sách đều cần thiết; chúng tôi khuyên bạn nên theo dõi[khóa học CS61C của Berkeley](http://inst.eecs.berkeley.edu/~cs61c/sp15/) “Những ý tưởng tuyệt vời trong kiến ​​trúc máy tính” để có thể đọc cụ thể. Các ghi chú bài giảng và phòng thử nghiệm có sẵn trực tuyến và các bài giảng trước đây có sẵn trên [Internet Archive](https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_). 

[![@todo Hệ thống máy tính: Góc nhìn của một lập trình viên](./Teach%20Yourself%20Computer%20Science_files/csapp.jpg)](http://csapp.cs.cmu.edu/3e/home.html)

> Phần cứng là nền tảng

- Mike Acton, Giám đốc kỹ thuật tại Insomniac Games
([xem cuộc nói chuyện CppCon của ông ấy](https://www.youtube.com/watch?v=rX0ItVEVjHc))

### Algorithms and Data Structures

We agree with decades of common wisdom that familiarity with common algorithms and data structures is one of the most empowering aspects of a computer science education. This is also a great place to train one’s general problem-solving abilities, which will pay off in every other area of study.

There are hundreds of books available, but our favorite is *[The Algorithm Design Manual](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/)* by Steven Skiena. He clearly loves algorithmic problem solving and typically succeeds in fostering similar enthusiasm among his students and readers. In our opinion, the two more commonly suggested texts (CLRS and Sedgewick) tend to be a little too proof-heavy for those learning the material primarily to help with practical problem solving.

For those who prefer video lectures, [Skiena generously provides his online](https://www.youtube.com/watch?v=A2bFN3MyNDA&list=PLOtl7M3yp-DX32N0fVIyvn7ipWKNGmwpp). We also really like Tim Roughgarden’s course, available [on Coursera](https://www.coursera.org/specializations/algorithms) and [elsewhere](http://timroughgarden.org/videos.html). Whether you prefer Skiena’s or Roughgarden’s lecture style will be a matter of personal preference. In fact, there are dozens of good alternatives, so if you happen to find another that you like, we encourage you to stick with it!

For practice, our preferred approach is for students to solve problems on [Leetcode](https://leetcode.com/). These tend to be interesting problems with decent accompanying solutions and discussions. They also help you test progress against questions that are commonly used in technical interviews at the more competitive software companies. We suggest solving around 100 random leetcode problems as part of your studies.

Finally, we strongly recommend *[How to Solve It](https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/)* as an excellent and unique guide to general problem solving; it’s as applicable to computer science as it is to mathematics.

[![The Algorithm Design Manual](./Teach%20Yourself%20Computer%20Science_files/skiena.jpg)](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/) [![How to Solve It](./Teach%20Yourself%20Computer%20Science_files/polya.jpg)](https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/)

> I have only one method that I recommend extensively—it’s called think before you write.

— Richard Hamming

### Mathematics for Computer Science

In some ways, computer science is an overgrown branch of applied mathematics. While many software engineers try—and to varying degrees succeed—at ignoring this, we encourage you to embrace it with direct study. Doing so successfully will give you an enormous competitive advantage over those who don’t.

The most relevant area of math for CS is broadly called “discrete mathematics”, where “discrete” is the opposite of “continuous” and is loosely a collection of interesting applied math topics outside of calculus. Given the vague definition, it’s not meaningful to try to cover the entire breadth of “discrete mathematics”. A more realistic goal is to build a working understanding of logic, combinatorics and probability, set theory, graph theory, and a little of the number theory informing cryptography. Linear algebra is an additional worthwhile area of study, given its importance in computer graphics and machine learning.

Our suggested starting point for discrete mathematics is the set of [lecture notes by László Lovász](http://www.cs.elte.hu/~lovasz/dmbook.ps). Professor Lovász did a good job of making the content approachable and intuitive, so this serves as a better starting point than more formal texts.

For a more advanced treatment, we suggest *[Mathematics for Computer Science](https://courses.csail.mit.edu/6.042/spring17/mcs.pdf)*, the book-length lecture notes for the MIT course of the same name. That course’s video lectures are also [freely available](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/), and are our recommended video lectures for discrete math.

For linear algebra, we suggest starting with the [Essence of linear algebra](https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab) video series, followed by Gilbert Strang’s [book](https://www.amazon.com/Introduction-Linear-Algebra-Gilbert-Strang/dp/0980232775/) and [video lectures](https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/).

> If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is.

— John von Neumann

### Operating Systems

*[Operating System Concepts](https://www.amazon.com/dp/1118063333/)* (the “Dinosaur book”) and *[Modern Operating Systems](https://www.amazon.com/dp/013359162X/)* are the “classic” books on operating systems. Both have attracted criticism for their lack of clarity and general student unfriendliness.

*Operating Systems: Three Easy Pieces* is a good alternative that’s [freely available online](http://pages.cs.wisc.edu/~remzi/OSTEP/). We particularly like the structure and readability of the book, and feel that the exercises are worthwhile.

After OSTEP, we encourage you to explore the design decisions of specific operating systems, through “{OS name} Internals” style books such as *[Lion's commentary on Unix](https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/)*, *[The Design and Implementation of the FreeBSD Operating System](https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/)*, and *[Mac OS X Internals](https://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542/)*. For Linux, we suggest Robert Love's fantastic [Linux Kernel Development](https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468).

A great way to consolidate your understanding of operating systems is to read the code of a small kernel and add features. One choice is [xv6](https://pdos.csail.mit.edu/6.828/2016/xv6.html), a port of Unix V6 to ANSI C and x86, maintained for a course at MIT. OSTEP has an appendix of potential [xv6 labs](http://pages.cs.wisc.edu/~remzi/OSTEP/lab-projects-xv6.pdf) full of great ideas for potential projects.

[![Operating Systems: Three Easy Pieces](./Teach%20Yourself%20Computer%20Science_files/ostep.jpeg)](http://pages.cs.wisc.edu/~remzi/OSTEP/)

### Computer Networking

Given that so much of software engineering is on web servers and clients, one of the most immediately valuable areas of computer science is computer networking. Our self-taught students who methodically study networking find that they finally understand terms, concepts and protocols they’d been surrounded by for years.

Our favorite book on the topic is *[Computer Networking: A Top-Down Approach](https://smile.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149/)*. The small projects and exercises in the book are well worth doing, and we particularly like the “Wireshark labs”, which they have [generously provided online](http://www-net.cs.umass.edu/wireshark-labs/).

For those who prefer video lectures, we suggest Stanford’s [*Introduction to Computer Networking course*](https://www.youtube.com/playlist?list=PLvFG2xYBrYAQCyz4Wx3NPoYJOFjvU7g2Z) previously available via Stanford's MOOC platform Lagunita, but sadly now only available as unofficial playlists on Youtube.

> You can’t gaze in the crystal ball and see the future. What the Internet is going to be in the future is what society makes it.

— Bob Kahn

[![Computer Networking: A Top-Down Approach](./Teach%20Yourself%20Computer%20Science_files/top-down.jpg)](https://smile.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149/)

### Databases

It takes more work to self-learn about database systems than it does with most other topics. It’s a relatively new (i.e. post 1970s) field of study with strong commercial incentives for ideas to stay behind closed doors. Additionally, many potentially excellent textbook authors have preferred to join or start companies instead.

Given the circumstances, we encourage self-learners to generally avoid textbooks and start with [recordings of CS 186](https://www.youtube.com/user/CS186Berkeley/videos), Joe Hellerstein’s databases course at Berkeley, and to progress to reading papers after.

One paper particularly worth mentioning for new students is “[Architecture of a Database System](http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf)”, which uniquely provides a high-level view of how relational database management systems (RDBMS) work. This will serve as a useful skeleton for further study.

*Readings in Database Systems*, better known as [the databases “Red Book”](http://www.redbook.io/), is a collection of papers compiled and edited by Peter Bailis, Joe Hellerstein and Michael Stonebraker. For those who have progressed beyond the level of the CS 186 content, the Red Book should be your next stop.

If you're adamant about using an introductory textbook, we suggest *[Database Management Systems](https://smile.amazon.com/Database-Management-Systems-Raghu-Ramakrishnan/dp/0072465638/)* by Ramakrishnan and Gehrke. For more advanced students, Jim Gray’s classic *[Transaction Processing: Concepts and Techniques](https://www.amazon.com/Transaction-Processing-Concepts-Techniques-Management/dp/1558601902)* is worthwhile, but we don’t encourage using this as a first resource.

Finally, data modeling is a neglected and poorly taught aspect of working with databases. Our suggested book on the topic is *[Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215)*.

[![Readings in Database Systems](./Teach%20Yourself%20Computer%20Science_files/redbook.jpg)](http://www.redbook.io/) [![Data and Reality](./Teach%20Yourself%20Computer%20Science_files/data-reality.jpg)](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215)

### Languages and Compilers

Most programmers learn languages, whereas most computer scientists learn *about* languages. This gives the computer scientist a distinct advantage over the programmer, even in the domain of programming! Their knowledge generalizes; they are able to understand the operation of a new language more deeply and quickly than those who have merely learned specific languages.

Our suggested introductory text is the excellent *[Crafting Interpreters](https://craftinginterpreters.com/contents.html)* by Bob Nystrom, available for free online. It's well organized, highly entertaining, and well suited to those whose primary goal is simply to better understand their languages and language tools. We suggest taking the time to work through the whole thing, attempting whichever of the "challenges" sustain your interest.

A more traditional recommendation is *[Compilers: Principles, Techniques & Tools](https://smile.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)*, commonly called “the Dragon Book”. Unfortunately, it’s not designed for self-study, but rather for instructors to pick out 1-2 semesters worth of topics for their courses.

If you elect to use the Dragon Book, it’s almost essential that you cherry-pick the topics, ideally with the help of a mentor. In fact, our suggested way to utilize the Dragon Book, if you so choose, is as a supplementary reference for a video lecture series. Our recommended one is [Alex Aiken’s, on edX](https://www.edx.org/course/compilers).

[![Compilers: Principles, Techniques & Tools](./Teach%20Yourself%20Computer%20Science_files/dragon.jpg)](https://smile.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)

> Don’t be a boilerplate programmer. Instead, build tools for users and other programmers. Take historical note of textile and steel industries: do you want to build machines and tools, or do you want to operate those machines?

— Ras Bodik at the start of his compilers course

### Distributed Systems

As computers have increased in number, they have also *spread*. Whereas businesses would previously purchase larger and larger mainframes, it’s typical now for even very small applications to run across multiple machines. Distributed systems is the study of how to reason about the trade-offs involved in doing so.

Our suggested book for self-study is Martin Kleppmann's *[Designing Data-Intensive Applications](https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/)*. Far better than a traditional textbook, DDIA is a highly readable book designed for practitioners, which somehow avoids sacrificing depth or rigor.

For those seeking a more traditional text, or who would prefer one that’s available for free online, we suggest Maarten van Steen and Andrew Tanenbaum’s *[Distributed Systems, 3rd Edition](https://www.distributed-systems.net/index.php/books/ds3/)*.

For those who prefer video, an excellent course with videos available online is [MIT’s 6.824](https://www.youtube.com/watch?v=cQP8WApzIQQ&list=PLrw6a1wE39_tb2fErI4-WkMbsvGQk9_UB), a graduate course taught by Robert Morris with readings available [here](https://pdos.csail.mit.edu/6.824/schedule.html).

No matter the choice of textbook or other secondary resources, study of distributed systems absolutely mandates reading papers. A good list is [here](http://dsrg.pdos.csail.mit.edu/papers/), and we would highly encourage attending your local [Papers We Love](http://paperswelove.org/) chapter.

[![Designing Data-Intensive Applications](./Teach%20Yourself%20Computer%20Science_files/ddia.jpg)](https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/)

Frequently asked questions
--------------------------

#### Who is the target audience for this guide?

We have in mind that you are a self-taught software engineer, bootcamp grad or precocious high school student, or a college student looking to supplement your formal education with some self-study. The question of when to embark upon this journey is an entirely personal one, but most people tend to benefit from having some professional experience before diving too deep into CS theory. For instance, we notice that students *love* learning about database systems if they have already worked with databases professionally, or about computer networking if they’ve worked on a web project or two.

#### What about AI/graphics/pet-topic-X?

We’ve tried to limit our list to computer science topics that we feel *every practicing software engineer* should know, irrespective of specialty or industry, but with a focus on systems. In our experience, these will be the highest ROI topics for the overwhelming majority of self-taught engineers and bootcamp grads, and provide a solid foundation for further study. Subsequently, you’ll be in a much better position to pick up textbooks or papers and learn the core concepts without much guidance. Here are our suggested starting points for a couple of common “electives”:

-   For artificial intelligence: do [Berkeley’s intro to AI course](http://ai.berkeley.edu/) by watching the videos and completing the excellent Pacman projects. As a textbook, use Russell and Norvig’s *Artificial Intelligence: A Modern Approach*.
-   For machine learning: do Andrew Ng’s Coursera course. Be patient, and make sure you understand the fundamentals before racing off to shiny new topics like deep learning.
-   For computer graphics: work through [Berkeley’s CS 184](http://inst.eecs.berkeley.edu/~cs184/fa12/onlinelectures.html) material, and use [Computer Graphics: Principles and Practice](https://www.amazon.com/Computer-Graphics-Principles-Practice-3rd/dp/0321399528) as a textbook.

#### How strict is the suggested sequencing?

Realistically, all of these subjects have a significant amount of overlap, and refer to one another cyclically. Take for instance the relationship between discrete math and algorithms: learning math first would help you analyze and understand your algorithms in greater depth, but learning algorithms first would provide greater motivation and context for discrete math. Ideally, you’d revisit both of these topics many times throughout your career.

As such, our suggested sequencing is mostly there to help you *just get started*… if you have a compelling reason to prefer a different sequence, then go for it. The most significant “pre-requisites” in our opinion are: computer architecture before operating systems or databases, and networking and operating systems before distributed systems.

#### How does this compare to Open Source Society or freeCodeCamp curricula?

When this guide was first written in 2016, the [OSS guide](https://github.com/open-source-society/computer-science) had too many subjects, suggested inferior resources for many of them, and provided no rationale or guidance around why or what aspects of particular courses are valuable. We strove to limit our list of courses to those which you *really should know* as a software engineer, irrespective of your specialty, and to help you understand why each course is included. In the subsequent years, the OSS guide has improved, but we still think that this one provides a clearer, more cohesive path.

freeCodeCamp is focused mostly on programming, not computer science. For why you might want to learn computer science, see [above](https://teachyourselfcs.com/#why). If you are new to programming, we suggest prioritizing that, and returning to this guide in a year or two.

#### What about language X?

Learning a particular programming language is on a totally different plane to learning about an area of computer science — learning a language is much *easier* and much *less valuable*. If you already know a couple of languages, we strongly suggest simply following our guide and fitting language acquisition in the gaps, or leaving it for afterwards. If you’ve learned programming well (such as through *Structure and Interpretation of Computer Programs*), and especially if you have learned compilers, it should take you little more than a weekend to learn the essentials of a new language, after which you can learn about the libraries/tooling/ecosystem on the job.

#### What about trendy technology X?

No single technology is important enough that learning to use it should be a core part of your education. On the other hand, it’s great that you’re excited to learn about that thing. The trick is to work backwards from the particular technology to the underlying field or concept, and learn that in depth before seeing how your trendy technology fits into the bigger picture.

#### Why are you still recommending SICP?

Look, just try it. Some people find SICP mind blowing, a characteristic shared by very few other books. If you don't like it, you can always try something else and perhaps return to SICP later.

#### Why are you still recommending the Dragon book?

The Dragon book is still the most complete single resource for compilers. It gets a bad rap, typically for overemphasizing certain topics that are less fashionable to cover in detail these days, such as parsing. The thing is, the book was never intended to be studied cover to cover, only to provide enough material for an instructor to put together a course. Similarly, a self-learner can choose their own adventure through the book, or better yet follow the suggestions that lecturers of public courses have made in their course outlines.

#### How can I get textbooks cheaply?

Many of the textbooks we suggest are freely available online, thanks to the generosity of their authors. For those that aren’t, we suggest buying used copies of older editions. As a general rule, if there has been more than a couple of editions of a textbook, it’s quite likely that an older edition is perfectly adequate. It’s certainly unlikely that the newest version is 10x better than an older one, even if that’s what the price difference is!

#### Who made this?

This guide was originally written by [Oz Nova](https://twitter.com/oznova_) and [Myles Byrne](https://twitter.com/quackingduck), with 2020 updates by Oz. It is based on our experience teaching foundational computer science to over 1000 mostly self-taught engineers and bootcamp grads in small group settings in San Francisco and live online. Thank you to all of our students for your continued feedback on self-teaching resources.

We're very confident that you could teach yourself everything above, given enough time and motivation. But if you'd prefer an intensive, structured, instructor-led program, you might be interested in our [Computer Science Intensive](https://bradfieldcs.com/csi/). We [DON'T](https://ozwrites.com/masters/) suggest pursuing a master's degree.

For updates to this guide and general computer science news and resources, you may also like to join Bradfield's mailing list:

Thanks for subscribing!

[hello@bradfieldcs.com](mailto:hello@bradfieldcs.com)
 San Francisco, California
 © 2016-2020 Bradfield School of Computer Science
